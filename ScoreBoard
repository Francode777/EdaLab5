import java.util.*;

class ScoreBoard {

    private TreeMap<Integer,ArrayList<String>> winTree = new TreeMap<>();//podre poner una lista de string
    private HashMap<String,Player> player = new HashMap();
    private int playedGame = 0;
    // gran fallo de este comando es que no se pueden obtener valores repetidos en el caso de que no se ocupara una lista
    
    ScoreBoard(){}
    
    public void addGameResult(String winnerPlayerName, String lossPlayerName, boolean draw){

        registerPlayer(winnerPlayerName);
        registerPlayer(lossPlayerName);

        Player winner = player.get(winnerPlayerName);
        Player loser = player.get(lossPlayerName);

        removeFromWinTree(winner);
        removeFromWinTree(loser);

        if (draw) {
            winner.addDraw();
            loser.addDraw();
        } else {
            winner.addWin();
            loser.addLoss();
        }

        addToWinTree(winner);
        addToWinTree(loser);

        playedGame++;
    }

    public void registerPlayer(String playerName){
        if(!checkPlayer(playerName)){
            Player newPLayer = new Player(playerName);
            player.put(playerName, newPLayer);
            winTree.putIfAbsent(0,new ArrayList<>());
            winTree.get(0).add(playerName);
        }else{
            System.out.println("Player already exists");
        }
    }

    public boolean checkPlayer(String playerName){
        return player.containsKey(playerName);
    }

    public Player[] winRange(int lo, int hi) {
        ArrayList<Player> result = new ArrayList<>();
        NavigableMap<Integer, ArrayList<String>> sub = winTree.descendingMap();

        for (Map.Entry<Integer, ArrayList<String>> entry : sub.entrySet()) {
            int wins = entry.getKey();
            if (wins <= lo && wins >= hi) {
                for (String name : entry.getValue()) {
                    result.add(player.get(name));
                }
            }
        }

        return result.toArray(new Player[0]);
    }

    public ArrayList<String> winSuccessor(int wins) {
        ArrayList<String> result = new ArrayList<>();
        Integer successorKey = winTree.higherKey(wins);
        if (successorKey != null) {
            result.addAll(winTree.get(successorKey));
        }
        return result;
    }

    private void removeFromWinTree(Player p) {
        int wins = p.getWins();
        ArrayList<String> list = winTree.get(wins);
        if (list != null) {
            list.remove(p.getPlayerName());
            if (list.isEmpty()) {
                winTree.remove(wins);
            }
        }
    }

    private void addToWinTree(Player p) {
        int wins = p.getWins();
        winTree.putIfAbsent(wins, new ArrayList<>());
        winTree.get(wins).add(p.getPlayerName());
    }


    public void printPlayers() {
        for (Player p : player.values()) {
            System.out.println(p.getPlayerName() + " → Wins: " + p.getWins() + ", Draws: " + p.getDraws() + ", Losses: " + p.getLosses());
        }
    }
}
class Main {
    public static void main(String[] args) {
        ScoreBoard scoreboard = new ScoreBoard();

        scoreboard.addGameResult("Alice", "Bob", false);    // Alice gana
        scoreboard.addGameResult("Alice", "Charlie", true); // Empate
        scoreboard.addGameResult("Bob", "Charlie", false);  // Bob gana
        scoreboard.addGameResult("Alice", "Bob", false);    // Alice gana de nuevo
        scoreboard.addGameResult("Charlie", "Bob", false);  // Charlie gana

        System.out.println("\nJugadores con entre 1 y 2 victorias:");
        for (String name : scoreboard.winRange(1, 2)) {
            System.out.println("- " + name);
        }

        System.out.println("\nJugadores con más victorias que 1:");
        for (String name : scoreboard.winSuccessor(1)) {
            System.out.println("- " + name);
        }

        System.out.println("\nEstado completo del ScoreBoard:");
        scoreboard.printPlayers();
    }
}
